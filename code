#include <Arduino.h>
#include <LiquidCrystal.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Wire.h>
#include <math.h>

// ==================== LCD WIRING ====================
LiquidCrystal lcd(17, 16, 4, 5, 18, 19); // RS, EN, D4, D5, D6, D7

// ==================== GLOBAL DECLARATIONS ====================
#define DO_I2C_ADDR 0x61

// ==================== RGB LED ====================
namespace RGB_LED {
  const int RED_PIN = 27;
  const int GREEN_PIN = 26;
  const int BLUE_PIN = 25;
  unsigned long lastUpdate = 0;
  float hue = 0.0;

  void setColor(int r, int g, int b) {
    analogWrite(RED_PIN, 255 - r);
    analogWrite(GREEN_PIN, 255 - g);
    analogWrite(BLUE_PIN, 255 - b);
  }

  void systemActiveEffect() {
    static unsigned long lastEffect = 0;
    if(millis() - lastEffect > 20) {
      float brightness = (exp(sin(millis()/1800.0 * PI)) - 0.3678) * 108.0;
      hue = fmod(hue + 0.3, 360);
      setColor(brightness * abs(sin(hue * PI / 180)),
               brightness * abs(sin((hue + 120) * PI / 180)),
               brightness * abs(sin((hue + 240) * PI / 180)));
      lastEffect = millis();
    }
  }

  void errorEffect() {
    static bool state = false;
    if(millis() - lastUpdate > 200) {
      state = !state;
      setColor(state ? 255 : 0, 0, 0);
      lastUpdate = millis();
    }
  }

  void setup() {
    pinMode(RED_PIN, OUTPUT);
    pinMode(GREEN_PIN, OUTPUT);
    pinMode(BLUE_PIN, OUTPUT);
    setColor(0, 0, 0);
    setColor(0, 255, 0); // Green startup blink
    delay(300);
    setColor(0, 0, 0);
  }
}

// ==================== SENSOR HEALTH MONITOR ====================
namespace SensorHealth {
  bool isAnalogDisconnected(int pin, int samples=50) {
    int minVal = 4096, maxVal = 0;
    float sum = 0;
    
    for(int i=0; i<samples; i++) {
      int val = analogRead(pin);
      sum += val;
      if(val < minVal) minVal = val;
      if(val > maxVal) maxVal = val;
      delay(1);
    }
    
    float avg = sum/samples;
    bool isStuckValue = (maxVal - minVal < 5);
    bool isNoisyFloating = (maxVal - minVal > 200) && (avg > 50 && avg < 4000);
    
    return isStuckValue || isNoisyFloating;
  }

  bool isAnalogConnected(int pin, int minValid, int maxValid, int samples=5) {
    if(isAnalogDisconnected(pin)) return false;
    
    int validCount = 0;
    for(int i=0; i<samples; i++) {
      int val = analogRead(pin);
      if(val > minValid && val < maxValid) validCount++;
      delay(2);
    }
    return (validCount >= samples-1);
  }
}

// ==================== TDS SENSOR ====================
namespace TDS_Sensor {
  const int TdsSensorPin = A0; // Changed back to A0 for stability
  #define VREF 3.3
  #define SCOUNT 30

  int analogBuffer[SCOUNT], analogBufferIndex = 0;
  float averageVoltage = 0, tdsValue = 0, temperature = 25.0;
  bool isConnected = false;
  
  float lastValidTDS = 0;
  unsigned long lastValidReadingTime = 0;
  const float MAX_TDS_JUMP = 50.0;

  int getMedianNum(int bArray[], int iFilterLen) {
    int bTab[SCOUNT];
    for(byte i=0; i<iFilterLen; i++) bTab[i] = bArray[i];
    for(int j=0; j<iFilterLen-1; j++) {
      for(int i=0; i<iFilterLen-j-1; i++) {
        if(bTab[i] > bTab[i+1]) {
          int temp = bTab[i];
          bTab[i] = bTab[i+1];
          bTab[i+1] = temp;
        }
      }
    }
    return (iFilterLen & 1) ? bTab[(iFilterLen-1)/2] 
                            : (bTab[iFilterLen/2] + bTab[iFilterLen/2-1])/2;
  }

  void setup() { 
    pinMode(TdsSensorPin, INPUT);
  }

  void loop() {
    static unsigned long analogSampleTime = 0, printTime = 0;
    
    if(millis() - analogSampleTime > 40) {
      analogBuffer[analogBufferIndex] = analogRead(TdsSensorPin);
      analogBufferIndex = (analogBufferIndex + 1) % SCOUNT;
      analogSampleTime = millis();
    }
    
    if(millis() - printTime > 800) {
      int analogBufferTemp[SCOUNT];
      memcpy(analogBufferTemp, analogBuffer, sizeof(analogBuffer));
      averageVoltage = getMedianNum(analogBufferTemp, SCOUNT) * VREF / 4096.0;
      
      isConnected = SensorHealth::isAnalogConnected(TdsSensorPin, 50, 4000) && 
                   (averageVoltage > 0.15);
      
      if(isConnected) {
        float compVoltage = averageVoltage / (1.0 + 0.02*(temperature - 25.0));
        float newTDS = (133.42*pow(compVoltage,3) - 255.86*pow(compVoltage,2) + 857.39*compVoltage)*0.5;
        
        if(lastValidReadingTime > 0 && millis() - lastValidReadingTime < 2000) {
          float maxAllowed = lastValidTDS + MAX_TDS_JUMP;
          float minAllowed = lastValidTDS - MAX_TDS_JUMP;
          if(newTDS > maxAllowed || newTDS < minAllowed) {
            newTDS = lastValidTDS;
          }
        }
        
        tdsValue = newTDS;
        lastValidTDS = newTDS;
        lastValidReadingTime = millis();
      } else {
        tdsValue = 0;
      }
      printTime = millis();
    }
  }
}

// ==================== TEMPERATURE SENSOR ====================
namespace DallasTemp_Sensor {
  const int SENSOR_PIN = 13;
  OneWire oneWire(SENSOR_PIN);
  DallasTemperature tempSensor(&oneWire);
  DeviceAddress sensorAddress;
  bool sensorFound = false, conversionPending = false;
  unsigned long lastRequest = 0;
  float tempCelsius = 0;
  bool isConnected = false;

  void setup() { 
    tempSensor.begin();
    sensorFound = tempSensor.getAddress(sensorAddress, 0);
    if(sensorFound) {
      tempSensor.setResolution(sensorAddress, 12);
      tempSensor.setWaitForConversion(false);
      pinMode(SENSOR_PIN, INPUT_PULLUP);
    }
  }

  void loop() {
    if(!sensorFound) {
      isConnected = false;
      return;
    }
    
    if(!conversionPending && (millis() - lastRequest > 1000)) {
      tempSensor.requestTemperatures();
      lastRequest = millis();
      conversionPending = true;
      return;
    }

    if(conversionPending && (millis() - lastRequest > 750)) {
      float rawTemp = tempSensor.getTempC(sensorAddress);
      if(rawTemp == DEVICE_DISCONNECTED_C) {
        isConnected = false;
        RGB_LED::errorEffect();
      } else {
        isConnected = true;
        tempCelsius = rawTemp;
        TDS_Sensor::temperature = tempCelsius;
        RGB_LED::systemActiveEffect();
      }
      conversionPending = false;
    }
  }
}

// ==================== pH SENSOR ====================
namespace PH_Sensor {
  const int PHSensorPin = A1;
  float calibration = 21.34, pHValue = 7.0;
  int buffer[10];
  bool isConnected = false;

  void setup() {
    pinMode(PHSensorPin, INPUT);
  }

  void loop() {
    static unsigned long lastPHUpdate = 0;
    if(millis() - lastPHUpdate > 2000) {
      isConnected = SensorHealth::isAnalogConnected(PHSensorPin, 100, 3900);
      
      if(isConnected) {
        for(int i=0; i<10; i++) buffer[i] = analogRead(PHSensorPin);
        for(int i=0; i<9; i++) {
          for(int j=i+1; j<10; j++) {
            if(buffer[i] > buffer[j]) {
              int temp = buffer[i];
              buffer[i] = buffer[j];
              buffer[j] = temp;
            }
          }
        }
        float avg = 0;
        for(int i=2; i<8; i++) avg += buffer[i];
        float volt = (avg * 3.3) / 4096.0 / 6.0; // ESP32 uses 3.3V reference
        pHValue = constrain((-5.70 * volt) + calibration, 0.0, 14.0);
      } else {
        pHValue = 7.0;
      }
      lastPHUpdate = millis();
    }
  }
}

// ==================== TURBIDITY SENSOR ====================
namespace Turbidity_Sensor {
  const int TurbidityPin = A2;
  int turbidityValue = 0;
  bool isConnected = false;

  void setup() {
    pinMode(TurbidityPin, INPUT);
  }

  void loop() {
    static unsigned long lastRead = 0;
    if(millis() - lastRead > 100) {
      isConnected = SensorHealth::isAnalogConnected(TurbidityPin, 50, 3000);
      turbidityValue = isConnected ? analogRead(TurbidityPin) : 0;
      lastRead = millis();
    }
  }
}

// ==================== DISSOLVED OXYGEN SENSOR ====================
namespace DO_Sensor {
  char response[32];
  float doValue = 0.0;
  unsigned long lastDORead = 0;
  bool isConnected = false;

  void setup() {
    Wire.begin();
    Wire.beginTransmission(DO_I2C_ADDR);
    Wire.write("C,1"); // Continuous mode
    Wire.endTransmission();
    delay(300);
  }

  void loop() {
    if(millis() - lastDORead > 2000) {
      Wire.requestFrom(DO_I2C_ADDR, 20);
      byte len = 0;
      while(Wire.available() && len < 31) {
        char c = Wire.read();
        if(c == 0) break;
        response[len++] = c;
      }
      response[len] = '\0';

      isConnected = (len > 0 && isdigit(response[0]));
      doValue = isConnected ? atof(response) : 0;
      
      if(isConnected) {
        char tempStr[8];
        dtostrf(DallasTemp_Sensor::tempCelsius, 3, 1, tempStr);
        Wire.beginTransmission(DO_I2C_ADDR);
        Wire.write("T,");
        Wire.write(tempStr);
        Wire.endTransmission();
      }
      
      lastDORead = millis();
    }
  }
}

// ==================== DISPLAY MANAGER ====================
namespace Display {
  void showAwaitingMessage() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Awaiting inputs");
    lcd.setCursor(0, 1);
    lcd.print("UwU");
  }

  void update() {
    static unsigned long lastUpdate = 0;
    if(millis() - lastUpdate > 500) {
      bool anyConnected = TDS_Sensor::isConnected || 
                         DallasTemp_Sensor::isConnected || 
                         PH_Sensor::isConnected || 
                         DO_Sensor::isConnected ||
                         Turbidity_Sensor::isConnected;
      
      if(!anyConnected) {
        showAwaitingMessage();
        lastUpdate = millis();
        return;
      }
      
      lcd.clear();
      
      // Line 1: TDS and Temperature
      lcd.setCursor(0, 0);
      lcd.print("TDS:");
      if(!TDS_Sensor::isConnected || TDS_Sensor::tdsValue < 10) {
        lcd.print("0.00");
      } else {
        lcd.print(TDS_Sensor::tdsValue, 0);
      }
      lcd.print(" T:");
      lcd.print(DallasTemp_Sensor::isConnected ? DallasTemp_Sensor::tempCelsius : 0, 1);
      
      // Line 2: pH and DO
      lcd.setCursor(0, 1);
      lcd.print("pH:");
      lcd.print(PH_Sensor::isConnected ? PH_Sensor::pHValue : 0, 1);
      lcd.print(" DO:");
      lcd.print(DO_Sensor::isConnected ? DO_Sensor::doValue : 0, 1);

      lastUpdate = millis();
    }
  }
}

// ==================== MAIN PROGRAM ====================
void setup() {
  Serial.begin(115200);
  lcd.begin(16, 2);
  lcd.print("System Starting");
  delay(2000);
  lcd.clear();

  RGB_LED::setup();
  TDS_Sensor::setup();
  DallasTemp_Sensor::setup();
  PH_Sensor::setup();
  Turbidity_Sensor::setup();
  DO_Sensor::setup();
}

void loop() {
  RGB_LED::systemActiveEffect();
  TDS_Sensor::loop();
  DallasTemp_Sensor::loop();
  PH_Sensor::loop();
  Turbidity_Sensor::loop();
  DO_Sensor::loop();
  Display::update();

  static unsigned long lastSerial = 0;
  if(millis() - lastSerial > 2000) {
    Serial.print("STATUS: ");
    Serial.print("TDS:"); Serial.print(TDS_Sensor::isConnected ? "CON" : "DIS");
    Serial.print(" TEMP:"); Serial.print(DallasTemp_Sensor::isConnected ? "CON" : "DIS");
    Serial.print(" pH:"); Serial.print(PH_Sensor::isConnected ? "CON" : "DIS");
    Serial.print(" DO:"); Serial.print(DO_Sensor::isConnected ? "CON" : "DIS");
    Serial.print(" TURB:"); Serial.println(Turbidity_Sensor::isConnected ? "CON" : "DIS");

    Serial.print("VALUES: ");
    Serial.print("TDS:"); Serial.print(TDS_Sensor::tdsValue);
    Serial.print("ppm Temp:"); Serial.print(DallasTemp_Sensor::tempCelsius);
    Serial.print("Â°C pH:"); Serial.print(PH_Sensor::pHValue, 1);
    Serial.print(" Turb:"); Serial.print(Turbidity_Sensor::turbidityValue);
    Serial.print(" DO:"); Serial.print(DO_Sensor::doValue, 1);
    Serial.println("mg/L");
    
    lastSerial = millis();
// copyright pyrolysis.wav
  }
}
