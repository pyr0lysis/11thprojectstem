#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <math.h>

// ==================== GLOBAL DECLARATIONS ====================
#define DO_I2C_ADDR 0x61
LiquidCrystal_I2C lcd(0x27, 16, 2);

// ==================== BUILT-IN RGB LED ====================
namespace RGB_LED {
  const int RED_PIN = 27;
  const int GREEN_PIN = 26;
  const int BLUE_PIN = 25;
  unsigned long lastUpdate = 0;
  float hue = 0.0;

  void setColor(int r, int g, int b) {
    analogWrite(RED_PIN, 255 - r);
    analogWrite(GREEN_PIN, 255 - g);
    analogWrite(BLUE_PIN, 255 - b);
  }

  void systemActiveEffect() {
    static unsigned long lastEffect = 0;
    if(millis() - lastEffect > 20) {
      float brightness = (exp(sin(millis()/1800.0 * PI)) - 0.3678) * 108.0;
      hue = fmod(hue + 0.3, 360);
      setColor(brightness * abs(sin(hue * PI / 180)),
               brightness * abs(sin((hue + 120) * PI / 180)),
               brightness * abs(sin((hue + 240) * PI / 180)));
      lastEffect = millis();
    }
  }

  void errorEffect() {
    static bool state = false;
    if(millis() - lastUpdate > 200) {
      state = !state;
      setColor(state ? 255 : 0, 0, 0);
      lastUpdate = millis();
    }
  }

  void setup() {
    pinMode(RED_PIN, OUTPUT);
    pinMode(GREEN_PIN, OUTPUT);
    pinMode(BLUE_PIN, OUTPUT);
    setColor(0, 0, 0);
    setColor(0, 255, 0);
    delay(300);
    setColor(0, 0, 0);
  }
}

// ==================== TDS SENSOR ====================
namespace TDS_Sensor {
  const int TdsSensorPin = A0;
  #define VREF 3.3
  #define SCOUNT 30

  int analogBuffer[SCOUNT], analogBufferIndex = 0;
  float averageVoltage = 0, tdsValue = 0, temperature = 25.0;

  int getMedianNum(int bArray[], int iFilterLen) {
    int bTab[SCOUNT];
    for(byte i=0; i<iFilterLen; i++) bTab[i] = bArray[i];
    for(int j=0; j<iFilterLen-1; j++) {
      for(int i=0; i<iFilterLen-j-1; i++) {
        if(bTab[i] > bTab[i+1]) {
          int temp = bTab[i];
          bTab[i] = bTab[i+1];
          bTab[i+1] = temp;
        }
      }
    }
    return (iFilterLen & 1) ? bTab[(iFilterLen-1)/2] 
                            : (bTab[iFilterLen/2] + bTab[iFilterLen/2-1])/2;
  }

  void setup() { pinMode(TdsSensorPin, INPUT); }

  void loop() {
    static unsigned long analogSampleTime = 0, printTime = 0;
    if(millis() - analogSampleTime > 40) {
      analogBuffer[analogBufferIndex] = analogRead(TdsSensorPin);
      analogBufferIndex = (analogBufferIndex + 1) % SCOUNT;
      analogSampleTime = millis();
    }
    if(millis() - printTime > 800) {
      int analogBufferTemp[SCOUNT];
      memcpy(analogBufferTemp, analogBuffer, sizeof(analogBuffer));
      averageVoltage = getMedianNum(analogBufferTemp, SCOUNT) * VREF / 4096.0;
      float compVoltage = averageVoltage / (1.0 + 0.02*(temperature - 25.0));
      tdsValue = fmaxf((133.42*pow(compVoltage,3) - 255.86*pow(compVoltage,2) + 857.39*compVoltage)*0.5, 0.0f);
      printTime = millis();
    }
  }
}

// ==================== TEMPERATURE SENSOR ====================
namespace DallasTemp_Sensor {
  const int SENSOR_PIN = 13;
  OneWire oneWire(SENSOR_PIN);
  DallasTemperature tempSensor(&oneWire);
  DeviceAddress sensorAddress;
  bool sensorFound = false, conversionPending = false;
  unsigned long lastRequest = 0;
  float tempCelsius = 0;

  void setup() { 
    tempSensor.begin();
    sensorFound = tempSensor.getAddress(sensorAddress, 0);
    if(sensorFound) {
      tempSensor.setResolution(sensorAddress, 12);
      tempSensor.setWaitForConversion(false);
      pinMode(SENSOR_PIN, INPUT_PULLUP);
    }
  }

  void loop() {
    if(!sensorFound) return;
    
    if(!conversionPending && (millis() - lastRequest > 1000)) {
      tempSensor.requestTemperatures();
      lastRequest = millis();
      conversionPending = true;
      return;
    }

    if(conversionPending && (millis() - lastRequest > 750)) {
      float rawTemp = tempSensor.getTempC(sensorAddress);
      if(rawTemp == DEVICE_DISCONNECTED_C) {
        Serial.println("Temp Sensor Error!");
        RGB_LED::errorEffect();
      } else {
        tempCelsius = rawTemp;
        TDS_Sensor::temperature = tempCelsius;
        RGB_LED::systemActiveEffect();
      }
      conversionPending = false;
    }
  }
}

// ==================== pH SENSOR ====================
namespace PH_Sensor {
  const int PHSensorPin = A1;
  float calibration = 21.34, pHValue = 7.0;
  int buffer[10];

  void setup() {
    pinMode(PHSensorPin, INPUT);
  }

  void calibrate(float knownpH) {
    float rawVoltage = analogRead(PHSensorPin) * 5.0 / 4096.0;
    calibration = knownpH + 5.70 * rawVoltage;
    Serial.print("Calibrated to ");
    Serial.print(knownpH);
    Serial.print(" pH at ");
    Serial.print(rawVoltage);
    Serial.println("V");
  }

  void loop() {
    static unsigned long lastPHUpdate = 0;
    if(millis() - lastPHUpdate > 2000) {
      for(int i=0; i<10; i++) buffer[i] = analogRead(PHSensorPin);
      for(int i=0; i<9; i++) {
        for(int j=i+1; j<10; j++) {
          if(buffer[i] > buffer[j]) {
            int temp = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = temp;
          }
        }
      }
      float avg = 0;
      for(int i=2; i<8; i++) avg += buffer[i];
      float volt = (avg * 5.0) / 4096.0 / 6.0;
      pHValue = constrain((-5.70 * volt) + calibration, 0.0, 14.0);
      lastPHUpdate = millis();
    }
  }
}

// ==================== TURBIDITY SENSOR ====================
namespace Turbidity_Sensor {
  const int TurbidityPin = A2;
  int turbidityValue = 0;

  void loop() {
    static unsigned long lastRead = 0;
    if(millis() - lastRead > 100) {
      turbidityValue = analogRead(TurbidityPin);
      lastRead = millis();
    }
  }
}

// ==================== DISSOLVED OXYGEN SENSOR ====================
namespace DO_Sensor {
  char response[32];
  float doValue = 0.0;
  unsigned long lastDORead = 0;

  void setup() {
    Wire.beginTransmission(DO_I2C_ADDR);
    Wire.write("C,1");
    Wire.endTransmission();
    delay(300);
  }

  void loop() {
    if(millis() - lastDORead > 2000) {
      Wire.requestFrom(DO_I2C_ADDR, 20);
      byte len = 0;
      while(Wire.available() && len < 31) {
        char c = Wire.read();
        if(c == 0) break;
        response[len++] = c;
      }
      response[len] = '\0';

      if(isdigit(response[0])) doValue = atof(response);
      
      char tempStr[8];
      dtostrf(DallasTemp_Sensor::tempCelsius, 3, 1, tempStr);
      Wire.beginTransmission(DO_I2C_ADDR);
      Wire.write("T,");
      Wire.write(tempStr);
      Wire.endTransmission();
      
      lastDORead = millis();
    }
  }
}

// ==================== DISPLAY MANAGER ====================
namespace Display {
  bool checkSensorsConnected() {
    // Check if any sensor is providing valid data
    bool tdsConnected = (TDS_Sensor::tdsValue > 0);
    bool tempConnected = (DallasTemp_Sensor::sensorFound && DallasTemp_Sensor::tempCelsius != DEVICE_DISCONNECTED_C);
    bool phConnected = (PH_Sensor::pHValue >= 0 && PH_Sensor::pHValue <= 14);
    bool doConnected = (DO_Sensor::doValue > 0);
    bool turbConnected = (Turbidity_Sensor::turbidityValue > 0);
    
    return tdsConnected || tempConnected || phConnected || doConnected || turbConnected;
  }

  void showAwaitingMessage() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Awaiting inputs");
    lcd.setCursor(0, 1);
    lcd.print("UwU");
  }

  void update() {
    static unsigned long lastUpdate = 0;
    if(millis() - lastUpdate > 500) {
      if(!checkSensorsConnected()) {
        showAwaitingMessage();
        lastUpdate = millis();
        return;
      }
      
      lcd.clear();
      
      // Line 1: TDS and Temperature
      lcd.setCursor(0, 0);
      lcd.print("TDS:");
      lcd.print(TDS_Sensor::tdsValue, 0);
      lcd.print(" T:");
      lcd.print(DallasTemp_Sensor::tempCelsius, 1);
      
      // Line 2: pH and DO
      lcd.setCursor(0, 1);
      lcd.print("pH:");
      lcd.print(PH_Sensor::pHValue, 1);
      lcd.print(" DO:");
      lcd.print(DO_Sensor::doValue, 1);

      lastUpdate = millis();
    }
  }
}

// ==================== MAIN PROGRAM ====================
void setup() {
  Serial.begin(115200);
  Wire.begin();
  RGB_LED::setup();

  lcd.init();
  lcd.backlight();
  lcd.print("System Starting");
  delay(2000);
  lcd.clear();

  TDS_Sensor::setup();
  DallasTemp_Sensor::setup();
  PH_Sensor::setup();
  DO_Sensor::setup();
}

void loop() {
  RGB_LED::systemActiveEffect();
  TDS_Sensor::loop();
  DallasTemp_Sensor::loop();
  PH_Sensor::loop();
  Turbidity_Sensor::loop();
  DO_Sensor::loop();
  Display::update();

  static unsigned long lastSerial = 0;
  if(millis() - lastSerial > 2000) {
    Serial.print(F("TDS:"));
    Serial.print(TDS_Sensor::tdsValue);
    Serial.print(F("ppm Temp:"));
    Serial.print(DallasTemp_Sensor::tempCelsius);
    Serial.print(F("Â°C pH:"));
    Serial.print(PH_Sensor::pHValue, 1);
    Serial.print(F(" Turb:"));
    Serial.print(Turbidity_Sensor::turbidityValue);
    Serial.print(F(" DO:"));
    Serial.print(DO_Sensor::doValue, 1);
    Serial.println(F("mg/L"));
    lastSerial = millis();
  }
}
